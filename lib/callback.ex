# Copyright 2018 - 2020, Mathijs Saey, Vrije Universiteit Brussel

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

defmodule Skitter.Callback do
  @moduledoc """
  Skitter callback.

  A callback is a piece of code which implements some functionality for a `Skitter.Component` or
  `Skitter.Strategy`. Callback are implemented as plain elixir functions which accept a state map
  as their first argument. They always return `t:result/0` as output.

  Besides the elixir function which implements the callback, callbacks also track meta-information
  about this function. This information should be stored by the module defining the callbacks. The
  behaviour defined in this module defines how this information can be retrieved. In order to
  ensure this information is correct, callbacks should be generated by
  `Skitter.DSL.Callback.defcb/2`.

  ## Examples

  Since callbacks need to be defined in a module the example code shown in this module's
  documentation assumes the following module is defined:

  ```
  defmodule ModuleWithCallbacks do
    @behaviour Skitter.Callback
    alias Skitter.Callback.{Result, Info}

    def _sk_callback_list, do: [example: 1]

    def _sk_callback_info(:example, 1) do
      %Info{read: [:field], write: [], publish: [:arg]}
    end

    def example(state, arg) do
      result = Map.get(state, :field)
      %Result{state: state, publish: [arg: arg], result: result}
    end
  end
  ```
  """
  alias Skitter.{Port, Component, Strategy, DefinitionError}

  # ---------------- #
  # Type & Behaviour #
  # ---------------- #

  @typedoc """
  Module in which the callback is embedded.

  Currently, only component and strategy modules can store callbacks.
  """
  @type parent :: Component.t() | Strategy.t()

  @typedoc """
  Arguments passed to a callback when it is called.

  The arguments are wrapped in a list.
  """
  @type args :: [any()]

  @typedoc """
  State passed to the callback when it is called.

  The state is wrapped in a dictionary.
  """
  @type state :: %{optional(atom()) => any()}

  @typedoc """
  Values returned by a callback when it is called.

  The following information is stored:

  - `:result`: The actual result of the callback, i.e. the final value returned in its body.
  - `:state`: The (possibly modified) state after calling the callback.
  - `:publish`: The list of output published by the callback.
  """
  @type result :: %__MODULE__.Result{
          result: any(),
          state: state(),
          publish: [{Port.t(), any()}]
        }

  @typedoc """
  Additional callback information. Can be retrieved with `info/2`.

  The following information is stored:

  - `:read`: The state fields read inside the callback.
  - `:write`: The state fields updated by the callback.
  - `:publish`: The ports this callback published to.
  """
  @type info :: %__MODULE__.Info{
          read: [atom()],
          write: [atom()],
          publish: [atom()]
        }

  @doc """
  Return the callback information of callback `name`, `arity`.
  """
  @callback _sk_callback_info(name :: atom(), arity()) :: info()

  @doc """
  Return a list with the names of all the callbacks defined in this module.
  """
  @callback _sk_callback_list() :: [{atom(), arity()}]

  # Struct Definitions
  # ------------------

  defmodule Result do
    @moduledoc false
    defstruct [:state, :publish, :result]
  end

  defmodule Info do
    @moduledoc false
    defstruct read: [], write: [], publish: []
  end

  # --------- #
  # Utilities #
  # --------- #

  @doc """
  Call the specified callback with `args` and `state`.

  ## Examples

      iex> call(ModuleWithCallbacks, :example, %{field: "Skitter"}, [:some_argument])
      %Result{state: %{field: "Skitter"}, publish: [arg: :some_argument], result: "Skitter"}

  """
  @spec call(parent(), atom(), state(), args()) :: result()
  def call(parent, name, state, args), do: apply(parent, name, [state | args])

  @doc false
  # Slightly more efficient version of call/4, can only be used when the "shape" of argument is
  # known upfront. Mainly used by the runtime system to call strategy hooks.
  defmacro call_inlined(parent, name, state, args) do
    quote do
      unquote(parent).unquote(name)(unquote(state), unquote_splicing(args))
    end
  end

  @doc """
  Obtain the callback information for callback `name`, `arity` in `parent`.

  ## Examples

      iex> info(ModuleWithCallbacks, :example, 1)
      %Info{read: [:field], write: [], publish: [:arg]}

  """
  @spec info(parent(), atom(), arity()) :: info()
  def info(parent, name, arity), do: parent._sk_callback_info(name, arity)

  @doc """
  Obtain the list of all callbacks defined in `parent`.

  ## Examples

      iex> list(ModuleWithCallbacks)
      [example: 1]

  """
  @spec list(parent()) :: [{atom(), arity()}]
  def list(parent), do: parent._sk_callback_list()

  @doc """
  Verify if the `property` of a callback satisfies `property`

  This function will lookup the property of a callback in its `t:info/0` struct and compare it to
  an expected value.

  - If the property is not present in `t:info/0`, `:invalid` is returned.

  - If the property has the same value as `expected`, `:ok` is returned.

  - If the values do not match, the actual value of the property is returned.

  As a special case, the properties, `read?`, `write?` and `publish?` may be passed along with a
  boolean value. When this value is `false`, `verify` ensures the corresponding property (`read`,
  `write`, or `publish`) is equal to the empty list. When `true` is passed, any value for `read`,
  `write` or `publish` is accepted. This is done to enable `verify/3` to ensure a callback does
  not update its state or publish data when this is not allowed.

  ## Examples

      iex> verify(ModuleWithCallbacks, :example, 1, :read, [:field])
      :ok

      iex> verify(ModuleWithCallbacks, :example, 1, :read, [])
      [:field]

      iex> verify(ModuleWithCallbacks, :example, 1, :red, [:field])
      :invalid

      iex> verify(ModuleWithCallbacks, :example, 1, :read?, true)
      :ok

      iex> verify(ModuleWithCallbacks, :example, 1, :read?, false)
      [:field]

      iex> verify(ModuleWithCallbacks, :example, 1, :write?, true)
      :ok

      iex> verify(ModuleWithCallbacks, :example, 1, :write?, false)
      :ok

  """
  @spec verify(parent(), atom(), arity(), atom(), any()) :: :ok | :invalid | any()

  def verify(_, _, _, property, true) when property in [:read?, :write?, :publish?], do: :ok

  def verify(parent, name, arity, :read?, false), do: verify(parent, name, arity, :read, [])
  def verify(parent, name, arity, :write?, false), do: verify(parent, name, arity, :write, [])
  def verify(parent, name, arity, :publish?, false), do: verify(parent, name, arity, :publish, [])

  def verify(parent, name, arity, property, expected) do
    case Map.get(info(parent, name, arity), property) do
      nil -> :invalid
      ^expected -> :ok
      value -> value
    end
  end

  @doc """
  Verify if the `property` of a callback satisfies `property`

  Works like `verify/4`, but raises a `Skitter.DefinitionError` if the properties do not match. If
  the properties do match, the module name of the callback module is returned.

  ## Examples

      iex> verify!(ModuleWithCallbacks, :example, 1, :write, [])
      ModuleWithCallbacks

      iex> verify!(ModuleWithCallbacks, :example, 1, :write, [:field])
      ** (Skitter.DefinitionError) Incorrect write for callback `example`, expected [:field], got []

      iex> verify!(ModuleWithCallbacks, :example, 1, :wrte, [])
      ** (Skitter.DefinitionError) `wrte` is not a valid property name

      iex> verify!(ModuleWithCallbacks, :example, 1, :read?, true)
      ModuleWithCallbacks

      iex> verify!(ModuleWithCallbacks, :example, 1, :read?, false)
      ** (Skitter.DefinitionError) Incorrect read for callback `example`, expected [], got [:field]

      iex> verify!(ModuleWithCallbacks, :example, 1, :write?, true)
      ModuleWithCallbacks

      iex> verify!(ModuleWithCallbacks, :example, 1, :write?, false)
      ModuleWithCallbacks

  """
  @spec verify!(parent(), atom(), arity(), atom(), any()) :: parent() | no_return()

  def verify!(parent, _, prop, _, true) when prop in [:read?, :write?, :publish?], do: parent

  def verify!(p, n, a, :read?, false), do: verify!(p, n, a, :read, [])
  def verify!(p, n, a, :write?, false), do: verify!(p, n, a, :write, [])
  def verify!(p, n, a, :publish?, false), do: verify!(p, n, a, :publish, [])

  def verify!(parent, name, arity, property, value) do
    case verify(parent, name, arity, property, value) do
      :ok ->
        parent

      :invalid ->
        raise DefinitionError, "`#{property}` is not a valid property name"

      actual ->
        raise DefinitionError,
              "Incorrect #{property} for callback `#{name}`, expected #{inspect(value)}, got #{
                inspect(actual)
              }"
    end
  end

  @doc """
  Verify the properties of a callback using `verify!/4`.

  This function accepts a keyword list of `{property, expected_value}` pairs and compares each of
  them with `verify!/4`.

  ## Examples

      iex> verify!(ModuleWithCallbacks, :example, 1, read?: true, write?: true)
      ModuleWithCallbacks

      iex> verify!(ModuleWithCallbacks, :example, 1, publish?: true, wrt: [])
      ** (Skitter.DefinitionError) `wrt` is not a valid property name

      iex> verify!(ModuleWithCallbacks, :example, 1, publish?: false)
      ** (Skitter.DefinitionError) Incorrect publish for callback `example`, expected [], got [:arg]
  """
  @spec verify!(parent(), atom(), arity(), [{atom(), any()}]) :: parent() | no_return()
  def verify!(parent, name, arity, properties) do
    properties
    |> Enum.map(fn {property, value} -> verify!(parent, name, arity, property, value) end)
    |> hd()
  end
end
