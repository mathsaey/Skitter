# Copyright 2018 - 2020, Mathijs Saey, Vrije Universiteit Brussel

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

defmodule Skitter.Callback do
  @moduledoc """
  Skitter callback.

  A callback is a piece of code which implements some functionality for a `Skitter.Component` or
  `Skitter.Strategy`. Callback are implemented as plain elixir functions which are called with an
  argument list and a state map. They always return a `t:result/0` as output.

  Besides the elixir function which implements the callback, callbacks also track meta-information
  about this function. This information should be stored by the module defining the callbacks. The
  behaviour defined in this module defines how this information can be retrieved. In order to
  ensure this information is correct, callbacks should be generated by
  `Skitter.DSL.Callback.callback/3`.

  ## Examples

  Since callbacks need to be defined in a module the example code shown in this module's
  documentation assumes the following module is defined:

  ```
  defmodule ModuleWithCallbacks do
    @behaviour Skitter.Callback
    alias Skitter.Callback.{Result, Info}

    def _sk_callback_list, do: [:example]

    def _sk_callback_info(:example) do
      %Info{arity: 1, read?: true, write?: false, publish?: true}
    end

    def example(state, [arg1]) do
      %Result{state: state, publish: [arg1: arg1], result: :some_value}
    end
  end
  ```
  """
  alias Skitter.{Port, Component, Strategy, DefinitionError}

  # ---------------- #
  # Type & Behaviour #
  # ---------------- #

  @typedoc """
  Module in which the callback is embedded.

  Currently, only component and strategy modules can store callbacks.
  """
  @type parent :: Component.t() | Strategy.t()

  @typedoc """
  Arguments passed to a callback when it is called.

  The arguments are wrapped in a list.
  """
  @type args :: [any()]

  @typedoc """
  State passed to the callback when it is called.

  The state is wrapped in a dictionary.
  """
  @type state :: %{optional(atom()) => any()}

  @typedoc """
  Values returned by a callback when it is called.

  The following information is stored:

  - `:result`: The actual result of the callback, i.e. the final value returned in its body.
  - `:state`: The (possibly modified) state after calling the callback.
  - `:publish`: The list of output published by the callback.
  """
  @type result :: %__MODULE__.Result{
          result: any(),
          state: state(),
          publish: [{Port.t(), any()}]
        }

  @typedoc """
  Additional callback information. Can be retrieved with `info/2`.

  The following information is stored:

  - `:arity`: The amount of arguments the callback accepts.
  - `:read?`: Whether the callback reads the state its passed.
  - `:write?`: Whether the callback updates its state.
  - `:publish?`: Whether the callback publishes any values.
  """
  @type info :: %__MODULE__.Info{
          arity: non_neg_integer(),
          read?: boolean(),
          write?: boolean(),
          publish?: boolean()
        }

  @doc """
  Return the callback information of callback `name`.
  """
  @callback _sk_callback_info(name :: atom()) :: info()

  @doc """
  Return a list with the names of all the callbacks defined in this module.
  """
  @callback _sk_callback_list() :: [atom()]

  # Struct Definitions
  # ------------------

  defmodule Result do
    @moduledoc false
    defstruct [:state, :publish, :result]
  end

  defmodule Info do
    @moduledoc false
    defstruct [:arity, read?: true, write?: true, publish?: true]
  end

  # --------- #
  # Utilities #
  # --------- #

  @doc """
  Call the specified callback with `args` and `state`.

  ## Examples

      iex> call(ModuleWithCallbacks, :example, %{hello: "Skitter"}, [:some_argument])
      %Result{state: %{hello: "Skitter"}, publish: [arg1: :some_argument], result: :some_value}

  """
  @spec call(parent(), atom(), state(), args()) :: result()
  def call(parent, name, state, args), do: apply(parent, name, [state, args])

  @doc """
  Obtain the callback information for callback `name` in `parent`.

  ## Examples

      iex> info(ModuleWithCallbacks, :example)
      %Info{arity: 1, read?: true, write?: false, publish?: true}

  """
  @spec info(parent(), atom()) :: info()
  def info(parent, name), do: parent._sk_callback_info(name)

  @doc """
  Obtain the list of all callbacks defined in `parent`.

  ## Examples

      iex> list(ModuleWithCallbacks)
      [:example]

  """
  @spec list(parent()) :: [atom()]
  def list(parent), do: parent._sk_callback_list()

  @doc """
  Verify if the `property` of a callback satisfies `property`

  This function will lookup the property of a callback in its `t:info/0` struct and compare it to
  an expected value.

  - If the property is not present in `t:info/0`, `{:invalid, property}` is returned.

  - If the property has the same value as `expected`, `:ok` is returned.

  - If the values do not match, `{:mismatch, property, expected_value, actual_value}` is returned.

  - When dealing with booleans, this function behaves somewhat differently: `:ok` is returned if
  expected is `true` and the actual value is `false`. This is done to enable `verify/4` to enforce
  restrictions.

  ## Examples

      iex> verify(ModuleWithCallbacks, :example, :arity, 1)
      :ok

      iex> verify(ModuleWithCallbacks, :example, :arity, 2)
      {:mismatch, :arity, 2, 1}

      iex> verify(ModuleWithCallbacks, :example, :arty, 2)
      {:invalid, :arty}

      iex> verify(ModuleWithCallbacks, :example, :read?, true)
      :ok

      iex> verify(ModuleWithCallbacks, :example, :read?, false)
      {:mismatch, :read?, false, true}

      iex> verify(ModuleWithCallbacks, :example, :write?, true)
      :ok

      iex> verify(ModuleWithCallbacks, :example, :write?, true)
      :ok

  """
  @spec verify(parent(), atom(), atom(), any()) ::
          :ok | {:invalid, atom()} | {:mismatch, atom(), any(), any()}
  def verify(parent, name, property, expected) do
    case Map.get(info(parent, name), property) do
      nil -> {:invalid, property}
      false when expected == true -> :ok
      value when value == expected -> :ok
      value -> {:mismatch, property, expected, value}
    end
  end

  @doc """
  Verify the properties of a callback.

  This function accepts a keyword list of `{property, expected_value}` pairs and compares each of
  them with `verify/4`. If each call to `verify/4` returns `:ok`, `:ok` is returned. Otherwise, a
  list of the results which were not equal to `:ok` are returned.

  ## Examples

      iex> verify(ModuleWithCallbacks, :example, arity: 1, read?: true, write?: true)
      :ok

      iex> verify(ModuleWithCallbacks, :example, arty: 3, arity: 2, read?: false, publish?: true)
      [{:invalid, :arty}, {:mismatch, :arity, 2, 1}, {:mismatch, :read?, false, true}]

  """
  @spec verify(parent(), atom(), [{atom(), any()}]) ::
          :ok | [{:invalid, atom()} | {:mismatch, atom(), any(), any()}]
  def verify(parent, name, properties \\ []) do
    properties
    |> Enum.map(fn {property, expected} -> verify(parent, name, property, expected) end)
    |> Enum.reject(&(&1 == :ok))
    |> case do
      [] -> :ok
      lst -> lst
    end
  end

  @doc """
  Verify the properties of a callback using `verify/3`.

  Raises a `DefintionError` if `verify/3` does not return `:ok`.

  ## Examples

      iex> verify!(ModuleWithCallbacks, :example, arity: 1, read?: true, write?: true)
      :ok

      iex> verify!(ModuleWithCallbacks, :example, publish?: true, arty: 3)
      ** (Skitter.DefinitionError) `arty` is not a valid property name

      iex> verify!(ModuleWithCallbacks, :example, publish?: true, arity: 3)
      ** (Skitter.DefinitionError) Incorrect arity for callback `example`, expected 3, got 1

  """
  @spec verify!(parent(), atom(), [{atom(), any()}]) :: :ok | no_return()
  def verify!(parent, name, properties \\ []) do
    case verify(parent, name, properties) do
      :ok ->
        :ok

      [{:invalid, property} | _] ->
        raise DefinitionError, "`#{property}` is not a valid property name"

      [{:mismatch, property, expected, actual} | _] ->
        raise DefinitionError,
              "Incorrect #{property} for callback `#{name}`, expected #{expected}, got #{actual}"
    end
  end
end
