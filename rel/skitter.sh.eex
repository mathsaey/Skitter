#!/bin/bash

# Copyright 2018 - 2020, Mathijs Saey, Vrije Universiteit Brussel

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# Script to start skitter runtimes or systems.
set -e

# ------------- #
# Documentation #
# ------------- #

local_desc="Use skitter locally"
deploy_desc="Deploy a set of workers and a master"
worker_desc="Manage a skitter worker"
master_desc="Manage a skitter master"

function global_usage() {
  printf '%s\n' "Skitter deploy script"

  printf '%s\n'   "Usage:"
  printf '\t%s\n' "skitter [GLOBAL OPTIONS] MODE COMMAND [COMMAND OPTIONS]"
  printf '\t%s\n' "skitter [-v | --version]"
  printf '\t%s\n' "skitter help [MODE]"

  printf '%s\n'         "Global Options:"
  printf '\t%s\t\t%s\n' "-v, --version"       "print the version and exit"
  printf '\t%s\t\t%s\n' "-d, --debug"         "Echo commands to execute"

  printf '%s\n'       "Modes:"
  printf '\t%s\t%s\n' "d, deploy" "$deploy_desc"
  printf '\t%s\t%s\n' "l, local"  "$local_desc"
  printf '\t%s\t%s\n' "w, worker" "$worker_desc"
  printf '\t%s\t%s\n' "m, master" "$master_desc"

  printf '%s\n'     "Environment:"
  printf '\t%s\n'   "SKITTER_PATH"
  printf '\t\t%s\n' "Specifies the location of the skitter runtime release files."
  printf '\t\t%s\n' "Defaults to the location of this script."
}

function deploy_usage() {
  printf '%s\n' "$deploy_desc"
  printf '\t%s\n' "This command spawns a set of worker nodes on the specified remote machines."
  printf '\t%s\n' "Afterwards, it spawns a master on the local machine, which automatically"
  printf '\t%s\n' "connects to the provided workers."
  printf '%s\n' "Usage:"
  printf '\t%s\n' "skitter deploy [COMMAND OPTIONS] WORKERS"
  printf '%s\n'         "Command Options:"
  printf '\t%s\t%s\n'   "-c, --cookie COOKIE"    "Override the default distribution cookie"
  printf '\t%s\t%s\n'   "-w, --working-dir PATH" "Change to this directory on the workers"
  printf '\t\t\t\t%s\n'                          "before executing any command. Defaults to"
  printf '\t\t\t\t%s\n'                          "the current working directory."
  printf '\t%s\t\t%s\n' "-s, --stop"             "Stop every worker node. Only needed when"
  printf '\t\t\t\t%s\n'                          "deploying fails for some reason."
  printf '%s\n'       "Command Arguments:"
  printf '\t%s\t%s\n' "WORKERS" "List of worker nodes to spawn, will be spawned in order"
}

function local_usage() {
  printf '%s\n' "$local_desc"
  printf '%s\n' "TODO"
}

function release_usage() {
  printf '%s\n'       "Commands:"
  printf '\t%s\t%s\n' "s, start"      "Starts a $1"
  printf '\t%s\t%s\n' "S, start_iex"  "Starts a $1 with an iex shell"
  printf '\t%s\t%s\n' "d, daemon"     "Starts a $1 as a daemon"
  printf '\t%s\t%s\n' "D, daemon_iex" "Starts a $1 as a daemon with iex attached"
  printf '\t%s\t\t%s\n' "remote"  "Open an iex shell connected to the running $1 daemon"
  printf '\t%s\t\t%s\n' "restart" "Restart the $1 daemon"
  printf '\t%s\t\t%s\n' "stop"    "Stop the $1 daemon"
  printf '\t%s\t\t%s\n' "pid"     "Get the pid of the $1 daemon"

  printf '%s\n'         "Command Options:"
  printf '\t%s\t%s\n'   "-c, --cookie COOKIE" "Override the default distribution cookie"
  printf '\t%s\t\t%s\n' "-n, --name NAME"     "Override the name of the node."
}

function worker_usage() {
  printf '%s\n' "$worker_desc"
  printf '%s\n' "Usage:"
  printf '\t%s\n' "skitter worker COMMAND [COMMAND OPTIONS] [MASTER]"

  release_usage "worker"
  printf '\t%s\n'   "--shutdown-with-master, --no-shutdown-with-master"
  printf '\t\t%s\n' "Automatically shut down the worker when the connected master node shuts down."
  printf '\t\t%s\n' "This flag can only be passed to start, start_iex, daemon and daemon_iex."
  printf '\t\t%s\n' "Defaults to true."

  printf '%s\n'       "Command Arguments:"
  printf '\t%s\t%s\n' "MASTER" "Attempt to connect to the master node at this address. Optional."
  printf '\t\t%s\n'            "This argument can only be passed to start, start_iex, daemon and daemon_iex."
}

function master_usage() {
  printf '%s\n' "$master_desc"

  printf '%s\n' "Usage:"
  printf '\t%s\n' "skitter master COMMAND [WORKERS]"

  release_usage "master"
  printf '%s\n'       "Command Arguments:"
  printf '\t%s\t%s\n' "WORKERS" "Connect to the provided worker nodes, optional."
  printf '\t\t%s\n'             "This argument can only be passed to start, start_iex, daemon and daemon_iex."
}

# --------- #
# Utilities #
# --------- #

function echoerr() {
  echo "$@" 1>&2
}

function argerr() {
  echoerr "$2"
  $1_usage
  exit 1
}

# ---------- #
# Mode logic #
# ---------- #

# Help
# ----

function do_help() {
  if [ -z $1 ]
  then
    global_usage
  else
    case "$1" in
      d|deploy)
        deploy_usage
        ;;
      l|local)
        local_usage
        ;;
      w|worker)
        worker_usage
        ;;
      m|master)
        master_usage
        ;;
      *)
        argerr "global" "Cannot get help, '$1' is not a valid command"
    esac
  fi
}

# Release Logic
# -------------

function rel_cmd() {
  if [ ! -d "$SKITTER_PATH/skitter_$mode" ]
  then
    echoerr "Attempted to start 'skitter_$mode', but it is not present in '\$SKITTER_PATH'"
    echoerr "Please ensure the 'skitter_$mode' release is built and present in '\$SKITTER_PATH'"
    echoerr "SKITTER_PATH = $SKITTER_PATH"
    exit 2
  fi
  $maybe_dry_run $SKITTER_PATH/skitter_$mode/bin/skitter_$mode $1
}

function maybe_add_name() {
  echo $2 | awk -v default_name=$1 '!/@/ {printf "%s@%s", default_name, $0} /@/ {print}'
}

function worker_start_parse() {
  while test $# -gt 0
    do
      case "$1" in
        --shutdown-with-master)
          $maybe_dry_run unset SKITTER_NO_SHUTDOWN_WITH_MASTER
          ;;
        --no-shutdown-with-master)
          $maybe_dry_run export SKITTER_NO_SHUTDOWN_WITH_MASTER=""
          ;;
        -c|--cookie)
          test $# -lt 2 && argerr "worker" "Missing value for optional argument '--cookie'."
          $maybe_dry_run export RELEASE_COOKIE="$2"
          shift
          ;;
        -n|--name)
          test $# -lt 2 && argerr "worker" "Missing value for optional argument '--name'."
          $maybe_dry_run export RELEASE_NODE="$2"
          shift
          ;;
        *)
          REMOTE=$(maybe_add_name "skitter_master" $1)
          $maybe_dry_run export SKITTER_MASTER=$REMOTE
          ;;
      esac
      shift
  done
}

function master_start_parse() {
  local workers

  while test $# -gt 0
    do
      case "$1" in
        -c|--cookie)
          test $# -lt 2 && argerr "master" "Missing value for optional argument '--cookie'."
          $maybe_dry_run export RELEASE_COOKIE="$2"
          shift
          ;;
        -n|--name)
          test $# -lt 2 && argerr "master" "Missing value for optional argument '--name'."
          $maybe_dry_run export RELEASE_NODE="$2"
          shift
          ;;
        *)
          local workers="$workers $(maybe_add_name "skitter_worker" $1)"
          ;;
      esac
      shift
  done

  if [ -n "$workers" ]
  then
    $maybe_dry_run export SKITTER_WORKERS="$workers"
  fi
}

function do_worker_master() {
  mode="$1"
  shift

  if [ $# -eq 0 ]
  then
    argerr "$mode" "Missing command"
  fi

  case $1 in
    s|start)
      shift
      "$mode"_start_parse $@
      rel_cmd "start"
      ;;
    S|start_iex)
      shift
      "$mode"_start_parse $@
      rel_cmd "start_iex"
      ;;
    d|daemon)
      shift
      "$mode"_start_parse $@
      rel_cmd "daemon"
      ;;
    D|daemon_iex)
      shift
      "$mode"_start_parse $@
      rel_cmd "daemon_iex"
      ;;
    remote|restart|stop|pid)
      rel_cmd $1
      ;;
    *)
      argerr "$mode" "Invalid command: '$1'"
  esac
}

# Deploy Logic
# ------------

function do_deploy() {
  local worker_cmd="daemon"
  local remote_dir=`pwd`
  local workers
  local cookie

  while test $# -gt 0
    do
      case "$1" in
        -w|--working-dir)
          test $# -lt 2 && argerr "deploy" "Missing value for optional argument '--working-dir'."
          remote_dir="$2"
          shift
          ;;
        -c|--cookie)
          test $# -lt 2 && argerr "deploy" "Missing value for optional argument '--cookie'."
          cookie="--cookie $2"
          shift
          ;;
        -s|--stop)
          worker_cmd="stop"
          ;;
        *)
          local workers="$workers $1"
          ;;
      esac
      shift
    done

    local cmd="cd ${remote_dir} && SKITTER_PATH=$SKITTER_PATH $script worker ${worker_cmd} ${cookie}"

    if [ -z "$workers" ]
    then
      argerr "deploy" "Missing workers"
    fi

    echo "⬡⬢⬡⬢ Skitter <%= @release.version %>"
    echo ""

    for remote in $workers
    do
      echo -n "$remote "
      $maybe_dry_run ssh "$remote" "$cmd"
      echo " ✓"
    done

    if [ $worker_cmd != "stop" ]
    then
      echo ""
      echo "Workers initialized, starting master."
      sleep 1
      do_worker_master master start_iex ${cookie} ${workers}
    fi
}

# ------------ #
# Script logic #
# ------------ #

# Store the script invocation so we can use it when deploying
script=$0

# No arguments: print usage and quit
if [ $# -eq 0 ]
then
  global_usage
  exit 0
fi

# Figure out the path to the skitter releases. This is specified by
# $SKITTER_PATH or the location of the script
if [ -z $SKITTER_PATH ]
then
  SELF=$(readlink "$0" || true)
  if [ -z "$SELF" ]; then SELF="$0"; fi
  PARENT_DIR="$(cd "$(dirname "$SELF")" && pwd -P)"
  SKITTER_PATH=$PARENT_DIR
fi

## Parse global options and mode
while test $# -gt 0
  do
    case "$1" in
      -v|--version)
        echo "skitter <%= @release.version %>"
        exit 0
        ;;
      -d|--debug)
        maybe_dry_run="echo"
        ;;
      *)
        break
        ;;
    esac
    shift
done

if [ $# -eq 0 ]
then
  argerr "global" "Missing command"
  exit 0
fi

# Parse the mode
case "$1" in
  h|help)
    shift
    do_help $@
    ;;
  w|worker)
    shift
    do_worker_master "worker" $@
    ;;
  m|master)
    shift
    do_worker_master "master" $@
    ;;
  d|deploy)
    shift
    do_deploy $@
    ;;
  l|local)
    shift
    do_local $@
    ;;
  *)
    argerr "'$1' is not a valid command"
    ;;
esac
